(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{284:function(a,s,t){a.exports=t.p+"assets/img/image-20230812135003725.03b33bb4.png"},285:function(a,s,t){a.exports=t.p+"assets/img/JMM.99cf0cde.png"},286:function(a,s,t){a.exports=t.p+"assets/img/image-20230812135855642.45fd7992.png"},287:function(a,s,t){a.exports=t.p+"assets/img/JMM2.1df5ad40.png"},288:function(a,s,t){a.exports=t.p+"assets/img/image-20230812141310370.15c6509f.png"},543:function(a,s,t){"use strict";t.r(s);var e=t(7),n=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java内存模型jmm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型jmm"}},[a._v("#")]),a._v(" Java内存模型JMM")]),a._v(" "),s("img",{attrs:{src:t(284),alt:"image-20230812135003725"}}),a._v(" "),s("p",[a._v("CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题")]),a._v(" "),s("p",[a._v("java虚拟机规范中试图定义一种java内存模型（JMM）来==屏蔽掉各种硬件和操作系统内存访问差异==，以实现让java程序在各个平台下都能达到一致的内存访问效果")]),a._v(" "),s("p",[a._v("JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。")]),a._v(" "),s("p",[a._v("原则：\nJMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的")]),a._v(" "),s("p",[a._v("能干嘛？\n1 通过JMM来实现线程和主内存之间的抽象关系。\n2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。")]),a._v(" "),s("h2",{attrs:{id:"三大特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三大特性"}},[a._v("#")]),a._v(" 三大特性")]),a._v(" "),s("h3",{attrs:{id:"可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[a._v("#")]),a._v(" 可见性")]),a._v(" "),s("p",[a._v("可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。")]),a._v(" "),s("img",{attrs:{src:t(285),alt:"img"}}),a._v(" "),s("p",[a._v('Java中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现"脏读"，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的==变量的主内存副本拷贝==，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成')]),a._v(" "),s("img",{attrs:{src:t(286),alt:"image-20230812135855642"}}),a._v(" "),s("h3",{attrs:{id:"原子性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[a._v("#")]),a._v(" 原子性")]),a._v(" "),s("p",[a._v("原子性是指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰")]),a._v(" "),s("h3",{attrs:{id:"有序性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[a._v("#")]),a._v(" 有序性")]),a._v(" "),s("p",[a._v('对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。\n但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。\n指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生"脏读"，简单说，\n两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。')]),a._v(" "),s("img",{attrs:{src:t(287),alt:"img"}}),a._v(" "),s("p",[a._v("单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。\n处理器在进行重排序时必须要考虑指令之间的数据依赖性\n多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测")]),a._v(" "),s("h2",{attrs:{id:"多线程对变量的读写过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程对变量的读写过程"}},[a._v("#")]),a._v(" 多线程对变量的读写过程")]),a._v(" "),s("p",[a._v("读取过程：\n由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将==变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量==，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:")]),a._v(" "),s("img",{attrs:{src:t(288),alt:"image-20230812141310370"}}),a._v(" "),s("p",[a._v("JMM定义了线程和主内存之间的抽象关系\n1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)\n2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)")]),a._v(" "),s("p",[a._v("我们定义的所有共享变量都储存在物理主内存中，每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)，线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)，不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)")]),a._v(" "),s("h2",{attrs:{id:"多线程先行发生原则之happens-before"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程先行发生原则之happens-before"}},[a._v("#")]),a._v(" 多线程先行发生原则之happens-before")]),a._v(" "),s("p",[a._v("在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before关系")]),a._v(" "),s("div",{staticClass:"language-ABAP line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-abap"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("\t线程A执行\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("x")]),a._v("\t线程B执行\n上述称之为：写后读\t\n 问题?\ny是否等于"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("呢？\n如果线程A的操作（x= "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("）happens"),s("span",{pre:!0,attrs:{class:"token token-operator punctuation"}},[a._v("-")]),a._v("before"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("先行发生"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("线程B的操作（y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("x")]),a._v("）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("那么可以确定线程B执行后y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" 一定成立;\n如果他们不存在happens"),s("span",{pre:!0,attrs:{class:"token token-operator punctuation"}},[a._v("-")]),a._v("before原则，那么y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" 不一定成立。\n这就是happens"),s("span",{pre:!0,attrs:{class:"token token-operator punctuation"}},[a._v("-")]),a._v("before原则的威力。-------------------》包含可见性和有序性的约束\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("h3",{attrs:{id:"happens-before总原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#happens-before总原则"}},[a._v("#")]),a._v(" happens-before总原则")]),a._v(" "),s("p",[a._v("==如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，==\n==而且第一个操作的执行顺序排在第二个操作之前。==")]),a._v(" "),s("p",[a._v("两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。\n如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。")]),a._v(" "),s("h3",{attrs:{id:"happens-before之8条"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#happens-before之8条"}},[a._v("#")]),a._v(" happens-before之8条")]),a._v(" "),s("p",[a._v("1.==次序规则==：一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；前一个操作的结果可以被后续的操作获取。")]),a._v(" "),s("p",[a._v("2.==锁定规则==：一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；")]),a._v(" "),s("p",[a._v("3.==volatile变量规则==：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，\n前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。")]),a._v(" "),s("p",[a._v("4.==传递规则==：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；")]),a._v(" "),s("p",[a._v("5.==线程启动规则==：Thread对象的start()方法先行发生于此线程的每一个动作")]),a._v(" "),s("p",[a._v("6.==线程中断规则==：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；可以通过Thread.interrupted()检测到是否发生中断")]),a._v(" "),s("p",[a._v("7.==线程终止规则==：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、\nThread::isAlive()的返回值等手段检测线程是否已经终止执行。")]),a._v(" "),s("p",[a._v("8.==对象终结规则==：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始；对象没有完成初始化之前，是不能调用finalized()方法的")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[a._v("假设存在线程A和B，线程A调用了setValue(1)，线程B调用了同一个对象的getValue()，")]),a._v(" "),s("p",[a._v("我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8 可以忽略，因为他们和这段代码毫无关系）：\n1 由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；\n2 两个方法都没有使用锁，所以不满足锁定规则；\n3 变量不是用volatile修饰的，所以volatile变量规则不满足；\n4 传递规则肯定不满足；")]),a._v(" "),s("p",[a._v("所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，\n但就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？")]),a._v(" "),s("ol",[s("li",[a._v("把getter/setter方法都定义为synchronized方法")]),a._v(" "),s("li",[a._v("把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景")])])])}),[],!1,null,null,null);s.default=n.exports}}]);