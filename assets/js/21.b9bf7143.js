(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{427:function(t,v,s){t.exports=s.p+"assets/img/12.f2c62167.jpg"},428:function(t,v,s){t.exports=s.p+"assets/img/tls.c89b71a7.png"},429:function(t,v,s){t.exports=s.p+"assets/img/ech_serverkey.52ecc486.png"},614:function(t,v,s){"use strict";s.r(v);var r=s(7),_=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"计算机网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),v("h2",{attrs:{id:"tcp-ip网络模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip网络模型"}},[t._v("#")]),t._v(" TCP/IP网络模型")]),t._v(" "),v("h3",{attrs:{id:"应用层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[t._v("#")]),t._v(" 应用层")]),t._v(" "),v("p",[t._v("应用层只专注为应用提供功能，如https，dns，smtp，ftp，telnet，并将数据传给传输层")]),t._v(" "),v("h3",{attrs:{id:"传输层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[t._v("#")]),t._v(" 传输层")]),t._v(" "),v("p",[t._v("传输层有两个协议，tcp（transmission control protocol），udp(use datagram protocol):传输控制协议和用户数据报协议")]),t._v(" "),v("p",[t._v("tcp是可靠传输，比如http应用层协议就基于tcp，具有超时重传，流量控制，拥塞控制等特性，")]),t._v(" "),v("p",[t._v("udp是不可靠传输，只保证数据包发送成功，不管是否到达，但是实时性高。传输效率也高，同时也可以在udp基础上进行改造使其具有上述tcp特性，适用于视频等允许少量数据丢失的场景")]),t._v(" "),v("h3",{attrs:{id:"网络层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[t._v("#")]),t._v(" 网络层")]),t._v(" "),v("p",[t._v("传输层设计的是简单高效，只需要负责和应用层的交接即可，真正传输的工作还是由网络层实现的。")]),t._v(" "),v("p",[t._v("网络层常见的协议是网际协议(Internet Protocol：IP)，IP协议会将传输层的报文作为数据部分，再加上自己的IP报头，如果大小超过MTU就会再次分片。")]),t._v(" "),v("p",[t._v("IP协议依靠IP地址来标识设备以实现数据设备间的传输。常见的IP地址分为IPv4和IPv6")]),t._v(" "),v("p",[t._v("对于IPv4，共有32位，分为四段")]),t._v(" "),v("img",{attrs:{src:s(427),alt:"img"}}),t._v(" "),v("h3",{attrs:{id:"网络接口层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络接口层"}},[t._v("#")]),t._v(" 网络接口层")]),t._v(" "),v("p",[t._v("在IP层数据头部添加MAC头，并封装成数据帧发送到网络")]),t._v(" "),v("p",[t._v("MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。")]),t._v(" "),v("p",[t._v("所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。")]),t._v(" "),v("h2",{attrs:{id:"tls"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tls"}},[t._v("#")]),t._v(" TLS")]),t._v(" "),v("h3",{attrs:{id:"rsa握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rsa握手过程"}},[t._v("#")]),t._v(" RSA握手过程")]),t._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:s(428),alt:"img"}}),t._v(" "),v("p",[t._v("TLS是中使用RSA需要完成4次握手，两个RTT时延")]),t._v(" "),v("ol",[v("li",[t._v("第一次握手：客户端发送Client Hello，声明自己的TSL版本，随机数以及支持的密码套件列表（密钥交换算法+签名算法+对称加密算法+摘要算法）")]),t._v(" "),v("li",[t._v("第二次握手：服务端根据信息选择密码套件，生成随机数，确认的TSL版本，返回Server Hello，然后发送Server Certificate，包含服务器的数字证书")]),t._v(" "),v("li",[t._v("第三次握手：客ECD户端验证证书可信后，生成新的随机数，并使用服务器公钥加密发送给服务端，服务端收到后使用自己的私钥解密，CS双方根据三个随机数生成会话密钥，客户端向服务端发送"),v("strong",[t._v("Change Cipher Spec")]),t._v("表示开始对称加密通话，然后客户端再将之前信息做摘要使用会话密钥加密发送给服务端")]),t._v(" "),v("li",[t._v("第四次握手：服务器也是同样的操作，发「"),v("strong",[t._v("Change Cipher Spec")]),t._v("」和「"),v("strong",[t._v("Encrypted Handshake Message")]),t._v("」消息，如果双方都验证加密和解密没问题，那么握手正式完成。")])]),t._v(" "),v("h3",{attrs:{id:"rsa算法的缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rsa算法的缺陷"}},[t._v("#")]),t._v(" RSA算法的缺陷")]),t._v(" "),v("p",[t._v("不支持前向保密，一旦服务端的私钥泄露，过去所有的TLS通讯密文d都会被破解")]),t._v(" "),v("h3",{attrs:{id:"ecdhe算法握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ecdhe算法握手过程"}},[t._v("#")]),t._v(" ECDHE算法握手过程")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("第一次握手：客户端发送Client Hello，表明自己的TLS版本，随机数，支持的密码套件列表")])]),t._v(" "),v("li",[v("p",[t._v("第二次握手：服务端选择合适的密码套件，确认的TLS版本，随机数，返回Server Hello，接着会发送自己的证书信息，然后发送Server Key Exchange消息\n"),v("img",{attrs:{src:s(429),alt:"img"}})]),t._v(" "),v("p",[t._v("这个过程服务器做了三件事：")]),t._v(" "),v("ul",[v("li",[t._v("选择了"),v("strong",[t._v("名为 x25519 的椭圆曲线")]),t._v("，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；")]),t._v(" "),v("li",[t._v("生成随机数作为服务端椭圆曲线的私钥，保留到本地；")]),t._v(" "),v("li",[t._v("根据基点 G 和私钥计算出"),v("strong",[t._v("服务端的椭圆曲线公钥")]),t._v("，这个会公开给客户端。")])]),t._v(" "),v("p",[t._v("为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。")]),t._v(" "),v("p",[t._v("随后，就是「"),v("strong",[t._v("Server Hello Done")]),t._v("」消息，服务端跟客户端表明信息传递完毕")])]),t._v(" "),v("li",[v("p",[t._v("第三次握手：客户端验证证书可信后，客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成"),v("strong",[t._v("客户端的椭圆曲线公钥")]),t._v("，然后用「"),v("strong",[t._v("Client Key Exchange")]),t._v("」消息发给服务端。"),v("strong",[t._v("最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的")]),t._v("。客户端会发一个「"),v("strong",[t._v("Change Cipher Spec")]),t._v("」消息，告诉服务端后续改用对称算法加密通信。客户端会发「"),v("strong",[t._v("Encrypted Handshake Message")]),t._v("」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。")])]),t._v(" "),v("li",[v("p",[t._v("第四次握手：服务端也会有一个同样的操作，发「"),v("strong",[t._v("Change Cipher Spec")]),t._v("」和「"),v("strong",[t._v("Encrypted Handshake Message")]),t._v("」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);