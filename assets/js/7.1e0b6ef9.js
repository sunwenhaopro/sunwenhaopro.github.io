(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{380:function(_,v,t){_.exports=t.p+"assets/img/30.689a1d31.jpg"},381:function(_,v,t){_.exports=t.p+"assets/img/31.397ef181.jpg"},382:function(_,v,t){_.exports=t.p+"assets/img/32.aa917b05.jpg"},383:function(_,v,t){_.exports=t.p+"assets/img/33.904c5637.jpg"},384:function(_,v,t){_.exports=t.p+"assets/img/34.05c38d92.jpg"},385:function(_,v,t){_.exports=t.p+"assets/img/35.2fe60c1b.jpg"},386:function(_,v,t){_.exports=t.p+"assets/img/36.63749220.jpg"},387:function(_,v,t){_.exports=t.p+"assets/img/37.2092a6ba.jpg"},388:function(_,v,t){_.exports=t.p+"assets/img/22-LWP.cd4d9a6e.jpg"},389:function(_,v,t){_.exports=t.p+"assets/img/38.5bbaded2.jpg"},611:function(_,v,t){"use strict";t.r(v);var s=t(7),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[_._v("#")]),_._v(" 操作系统")]),_._v(" "),v("h2",{attrs:{id:"进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[_._v("#")]),_._v(" 进程")]),_._v(" "),v("p",[_._v("进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配、调度和保护的基本单位。")]),_._v(" "),v("p",[_._v("用户进程：用户程序所创建的进程\n系统进程：操作系统自身模块运行系统所创建的进程")]),_._v(" "),v("blockquote",[v("p",[_._v("进程与程序的区别：")]),_._v(" "),v("ol",[v("li",[_._v("进程能更加真实的描述并发，而程序不能")]),_._v(" "),v("li",[_._v("进程是由程序和数据和进程控制块三部分组成")]),_._v(" "),v("li",[_._v("程序是静态的，进程是动态的")]),_._v(" "),v("li",[_._v("进程是有生命周期的，程序是相对长久的")]),_._v(" "),v("li",[_._v("一个程序可以对应多个进程，反之亦然")]),_._v(" "),v("li",[_._v("进程具有创建其他进程的功能，而程序没有")])])]),_._v(" "),v("h3",{attrs:{id:"进程的状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态"}},[_._v("#")]),_._v(" 进程的状态")]),_._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:t(380),alt:"七种状态变迁"}}),_._v(" "),v("ul",[v("li",[v("p",[v("em",[_._v("NULL -> 创建状态")]),_._v("：一个新进程被创建时的第一个状态；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("创建状态 -> 就绪状态")]),_._v("：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("就绪态 -> 运行状态")]),_._v("：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("运行状态 -> 结束状态")]),_._v("：当进程已经运行完成或出错时，会被操作系统作结束状态处理；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("运行状态 -> 就绪状态")]),_._v("：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("运行状态 -> 阻塞状态")]),_._v("：当进程请求某个事件且必须等待时，例如请求 I/O 事件；")])]),_._v(" "),v("li",[v("p",[v("em",[_._v("阻塞状态 -> 就绪状态")]),_._v("：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；")]),_._v(" "),v("p",[_._v("阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；")]),_._v(" "),v("p",[_._v("就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；")])])]),_._v(" "),v("h3",{attrs:{id:"进程的控制结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的控制结构"}},[_._v("#")]),_._v(" 进程的控制结构")]),_._v(" "),v("p",[_._v("==进程控制块PCB==数据结构来描述进程，是进程的唯一标识符")]),_._v(" "),v("p",[v("strong",[_._v("进程描述信息：")])]),_._v(" "),v("ul",[v("li",[_._v("进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；")]),_._v(" "),v("li",[_._v("用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；")])]),_._v(" "),v("p",[v("strong",[_._v("进程控制和管理信息：")])]),_._v(" "),v("ul",[v("li",[_._v("进程当前状态，如 new、ready、running、waiting 或 blocked 等；")]),_._v(" "),v("li",[_._v("进程优先级：进程抢占 CPU 时的优先级；")])]),_._v(" "),v("p",[v("strong",[_._v("资源分配清单：")])]),_._v(" "),v("ul",[v("li",[_._v("有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。")])]),_._v(" "),v("p",[v("strong",[_._v("CPU 相关信息：")])]),_._v(" "),v("ul",[v("li",[_._v("CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。")])]),_._v(" "),v("p",[_._v("PCB之间是通过==链表==组织起来的，把==相同状态==的的链表链在一起组成各种队列（这点和MySQL中buffer pool里面空闲页和脏页管理非常像）")]),_._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:t(381),alt:"就绪队列和阻塞队列"}}),_._v(" "),v("p",[_._v("除了链表还有==索引==的方式")]),_._v(" "),v("h3",{attrs:{id:"进程上下文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程上下文"}},[_._v("#")]),_._v(" 进程上下文")]),_._v(" "),v("p",[_._v("进程本身和其运行环境构成，可分为两个部分：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("处理器部分信息:\n寄存器现场信息，PC，PSW等")])]),_._v(" "),v("li",[v("p",[_._v("内存部分信息\n系统级上下文：PCB表和调用栈信息等\n用户级上下文：进程代码，数据，栈等")])])]),_._v(" "),v("h2",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[_._v("#")]),_._v(" 线程")]),_._v(" "),v("p",[_._v("线程是进程中一个运行的实体，是CPU的调度单位，资源分配的单位仍然是进程。引入线程的基本目的就是将进程进行细粒度的划分，以降低开销进一步提升系统的并发度")]),_._v(" "),v("h3",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[_._v("#")]),_._v(" 特点")]),_._v(" "),v("p",[_._v("线程是进程当中的一条执行流程")]),_._v(" "),v("p",[_._v("同一个进程内==多个==线程之间可以==共享==代码段，数据段，打开的文件等资源（java运行时区域）")]),_._v(" "),v("img",{attrs:{src:t(382),alt:"多线程"}}),_._v(" "),v("p",[_._v("但是当进程中的一个线程崩溃时，会导致其所属的所有线程崩溃（C/C++,java不会，JVM自定义了信号处理器，c/c++线程崩溃会向进程发送信号，收到信号调用默认的监听器kill 进程，详情可以参见==Linux-Unix编程手册第20章==）")]),_._v(" "),v("h3",{attrs:{id:"线程和进程的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程的比较"}},[_._v("#")]),_._v(" 线程和进程的比较")]),_._v(" "),v("ul",[v("li",[_._v("进程是资源分配的单位，线程是CPU调度单位")]),_._v(" "),v("li",[_._v("进程拥有完整的资源，而线程只独享必不可少的资源如程序计数器")]),_._v(" "),v("li",[_._v("线程同样具有三种基本状态，能够状态转换")]),_._v(" "),v("li",[_._v("线程能够减少并发执行的时间和空间开销")])]),_._v(" "),v("p",[_._v("对于，线程相比进程能减少开销，体现在：")]),_._v(" "),v("ul",[v("li",[_._v("线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；")]),_._v(" "),v("li",[_._v("线程的终止时间比进程快，因为线程释放的资源相比进程少很多；")]),_._v(" "),v("li",[_._v("同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；")]),_._v(" "),v("li",[_._v("由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了")])]),_._v(" "),v("p",[_._v("时间效率和空间效率都完胜。")]),_._v(" "),v("blockquote",[v("p",[_._v("CPU调度的是线程，而不是进程。线程是进程的一部分，它是CPU执行的最小单位。一个进程可以包含多个线程，它们共享进程的资源，如内存、文件、网络等。CPU调度的目的是让多个线程合理地分配CPU的时间，提高系统的效率和响应性。")]),_._v(" "),v("p",[_._v("调度算法的名称可能会引起一些混淆，因为它们实际上是针对线程的，而不是进程。不过，有一些原因可以解释为什么调度算法通常被称为进程调度算法：")]),_._v(" "),v("ul",[v("li",[_._v("在早期的操作系统中，进程是CPU执行的唯一单位，没有线程的概念。因此，当时的调度算法确实是针对进程的，而且这个术语一直沿用至今。")]),_._v(" "),v("li",[_._v("在一些操作系统中，如Windows，线程是内核对象，而进程是线程的容器。因此，从内核的角度来看，调度的对象是线程，而从用户的角度来看，调度的对象是进程。这种双重视角可能导致调度算法的名称不一致。")]),_._v(" "),v("li",[_._v("在一些操作系统中，如Linux，线程和进程是同一种实体，只是有不同的属性。Linux中的线程其实是一种特殊的进程，它们共享某些资源，如地址空间、文件描述符等，但是有自己的标识符、寄存器、栈等。因此，从Linux的角度来看，调度的对象是进程，而线程只是进程的一种形式。")]),_._v(" "),v("li",[_._v("综上所述，调度算法的名称可能会因为历史、设计或者实现的原因而有所不同，但是它们的本质都是针对线程的，因为线程是CPU执行的最小单位。")])])]),_._v(" "),v("p",[_._v("对于我的理解，进程就是一个空壳子，里面只有一些资源，不会尽心CPU操作，壳子里面存在线程，线程可以调用进程厂房里面的资源，也可以拥有自己的私有资源，其能够使用CPU进行运算等操作，CPU调度就是调度的线程，但是线程和进程必须捆绑出现，不可能只有进程，或者只有线程。两者是共生关系，只不过进程可以和多个线程建立共生关系，线程只能和一个进程建立共生关系。")]),_._v(" "),v("h3",{attrs:{id:"线程的上下文切换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的上下文切换"}},[_._v("#")]),_._v(" 线程的上下文切换")]),_._v(" "),v("p",[_._v("操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。")]),_._v(" "),v("ul",[v("li",[_._v("当进程只有一个线程时，可以认为进程就等于线程；")]),_._v(" "),v("li",[_._v("当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；")])]),_._v(" "),v("p",[_._v("线程上下文切换的是什么？")]),_._v(" "),v("ul",[v("li",[_._v("当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；")]),_._v(" "),v("li",[v("strong",[_._v("当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据")]),_._v("；")])]),_._v(" "),v("h3",{attrs:{id:"线程的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的实现"}},[_._v("#")]),_._v(" 线程的实现")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("用户线程（User Thread）")]),_._v("：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；")]),_._v(" "),v("li",[v("strong",[_._v("内核线程（Kernel Thread）")]),_._v("：在内核中实现的线程，是由内核管理的线程；")]),_._v(" "),v("li",[v("strong",[_._v("轻量级进程（LightWeight Process）")]),_._v("：在内核中来支持用户线程；")])]),_._v(" "),v("h4",{attrs:{id:"用户线程和内核线程的对应关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户线程和内核线程的对应关系"}},[_._v("#")]),_._v(" 用户线程和内核线程的对应关系：")]),_._v(" "),v("p",[_._v("1：1       N：1   M：N")]),_._v(" "),v("img",{attrs:{src:t(383),alt:"多对一"}}),_._v(" "),v("img",{attrs:{src:t(384),alt:"一对一"}}),_._v(" "),v("img",{attrs:{src:t(385),alt:"多对多"}}),_._v(" "),v("p",[v("strong",[_._v("1 : 1 模式")])]),_._v(" "),v("p",[_._v("一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。")]),_._v(" "),v("ul",[v("li",[_._v("优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP；")]),_._v(" "),v("li",[_._v("缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大。")])]),_._v(" "),v("p",[v("strong",[_._v("N : 1 模式")])]),_._v(" "),v("p",[_._v("多个用户线程对应一个 LWP 再对应一个内核线程，如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。")]),_._v(" "),v("ul",[v("li",[_._v("优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高；")]),_._v(" "),v("li",[_._v("缺点：一个用户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的。")])]),_._v(" "),v("p",[v("strong",[_._v("M : N 模式")])]),_._v(" "),v("p",[_._v("根据前面的两个模型混搭一起，就形成 "),v("code",[_._v("M:N")]),_._v(" 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。")]),_._v(" "),v("ul",[v("li",[_._v("优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。")])]),_._v(" "),v("p",[v("strong",[_._v("组合模式")])]),_._v(" "),v("p",[_._v("如上图的进程 5，此进程结合 "),v("code",[_._v("1:1")]),_._v(" 模型和 "),v("code",[_._v("M:N")]),_._v(" 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。")]),_._v(" "),v("h4",{attrs:{id:"用户线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户线程"}},[_._v("#")]),_._v(" 用户线程")]),_._v(" "),v("p",[_._v("用户线程是基于用户态的线程管理库来实现的，那么"),v("strong",[_._v("线程控制块（*Thread Control Block, TCB*）")]),_._v(" 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。")]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。")])]),_._v(" "),v("p",[_._v("用户级线程的模型，也就类似前面提到的"),v("strong",[_._v("多对一")]),_._v("的关系，即多个用户线程对应同一个内核线程，如下图所示：")]),_._v(" "),v("img",{attrs:{src:t(386),alt:"用户级线程模型"}}),_._v(" "),v("p",[_._v("用户线程的"),v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；")]),_._v(" "),v("li",[_._v("用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；")])]),_._v(" "),v("p",[_._v("用户线程的"),v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。")]),_._v(" "),v("li",[_._v("当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。")]),_._v(" "),v("li",[_._v("由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；")])]),_._v(" "),v("h4",{attrs:{id:"内核线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内核线程"}},[_._v("#")]),_._v(" 内核线程")]),_._v(" "),v("p",[v("strong",[_._v("内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。")])]),_._v(" "),v("p",[_._v("内核线程的模型，也就类似前面提到的"),v("strong",[_._v("一对一")]),_._v("的关系，即一个用户线程对应一个内核线程，如下图所示：")]),_._v(" "),v("img",{attrs:{src:t(387),alt:"内核线程模型"}}),_._v(" "),v("p",[_._v("内核线程的"),v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；")]),_._v(" "),v("li",[_._v("分配给线程，多线程的进程获得更多的 CPU 运行时间；")])]),_._v(" "),v("p",[_._v("内核线程的"),v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；")]),_._v(" "),v("li",[_._v("线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；")])]),_._v(" "),v("h4",{attrs:{id:"轻量级进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轻量级进程"}},[_._v("#")]),_._v(" 轻量级进程")]),_._v(" "),v("p",[v("strong",[_._v("轻量级进程（*Light-weight process，LWP*）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度")]),_._v("。")]),_._v(" "),v("p",[_._v("在大多数系统中，"),v("strong",[_._v("LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息")]),_._v("。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。")]),_._v(" "),v("p",[_._v("在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("1 : 1")]),_._v("，即一个 LWP 对应 一个用户线程；")]),_._v(" "),v("li",[v("code",[_._v("N : 1")]),_._v("，即一个 LWP 对应多个用户线程；")]),_._v(" "),v("li",[v("code",[_._v("M : N")]),_._v("，即多个 LWP 对应多个用户线程；")])]),_._v(" "),v("p",[_._v("接下来针对上面这三种对应关系说明它们优缺点。先看下图的 LWP 模型：")]),_._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:t(388),alt:"LWP 模型"}}),_._v(" "),v("h2",{attrs:{id:"调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度"}},[_._v("#")]),_._v(" 调度")]),_._v(" "),v("p",[_._v("进程都希望自己能够占用 CPU 进行工作，那么这涉及到前面说过的进程上下文切换。")]),_._v(" "),v("h3",{attrs:{id:"调度的时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度的时机"}},[_._v("#")]),_._v(" 调度的时机")]),_._v(" "),v("h2",{attrs:{id:"进程间通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信方式"}},[_._v("#")]),_._v(" 进程间通信方式")]),_._v(" "),v("h3",{attrs:{id:"管道"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[_._v("#")]),_._v(" 管道")]),_._v(" "),v("div",{staticClass:"language-bash line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[_._v("$ "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("ps")]),_._v(" auxf "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("grep")]),_._v(" mysql\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("管道是一种单向传输的结构，一端写入，一端读取。分为匿名管道（父子进程之间）和命名管道（FIFO）。管道随进程的创建二创建，销毁而销毁")]),_._v(" "),v("p",[_._v("匿名管道类似于在内核申请了一篇内核缓冲区\n命名管道是创建了一个设备文件（Linux设备皆文件的思想）")]),_._v(" "),v("p",[_._v("主要是由文件描述符FS实现的。参见《Linux-Unix编程手册第44章》")]),_._v(" "),v("h3",{attrs:{id:"消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[_._v("#")]),_._v(" 消息队列")]),_._v(" "),v("p",[_._v("消息队列是保存到内核的一个链表。")]),_._v(" "),v("p",[_._v("AB进程之间通信：A将数据发送到管道，B需要的时候就去管道中取。")]),_._v(" "),v("p",[_._v("消息队列需要手动释放，不会随着进程销毁而销毁")]),_._v(" "),v("ul",[v("li",[_._v("通信不及时")]),_._v(" "),v("li",[_._v("消息大小有限制")]),_._v(" "),v("li",[_._v("消息队列通信过程中存在数据在用户态和内核态的复制开销")])]),_._v(" "),v("h3",{attrs:{id:"共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),v("p",[_._v("共享内存就是开辟一片虚拟内存空间，映射到相同的物理内存中去。不需要来回拷贝就能实现通信")]),_._v(" "),v("img",{attrs:{src:t(389),alt:"img"}}),_._v(" "),v("h3",{attrs:{id:"信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[_._v("#")]),_._v(" 信号量")]),_._v(" "),v("p",[_._v("多个进程并发操作共享内存就可能发生数据覆盖的情况，信号量机制就是避免多进程竞争资源。")]),_._v(" "),v("p",[_._v("信号量是一个整型计数器，主要实现进程间的互斥和同步。")]),_._v(" "),v("p",[_._v("信号量表示资源的数量，控制信号量的方式有两种原子操作：")]),_._v(" "),v("ul",[v("li",[_._v("一个是 "),v("strong",[_._v("P 操作")]),_._v("，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。")]),_._v(" "),v("li",[_._v("另一个是 "),v("strong",[_._v("V 操作")]),_._v("，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；")])]),_._v(" "),v("p",[_._v("P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。")]),_._v(" "),v("p",[_._v("信号初始化为 "),v("code",[_._v("1")]),_._v("，就代表着是"),v("strong",[_._v("互斥信号量")]),_._v("，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。")]),_._v(" "),v("p",[_._v("信号初始化为 "),v("code",[_._v("0")]),_._v("，就代表着是"),v("strong",[_._v("同步信号量")]),_._v("，它可以保证进程 A 应在进程 B 之前执行。")]),_._v(" "),v("p",[_._v("详情参见《Linux-Unix操作手册第53章》")]),_._v(" "),v("h3",{attrs:{id:"信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[_._v("#")]),_._v(" 信号")]),_._v(" "),v("p",[_._v("信号是进程间通信机制中"),v("strong",[_._v("唯一的异步通信机制")]),_._v("，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。")]),_._v(" "),v("p",[v("strong",[_._v("1.执行默认操作")]),_._v("。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。")]),_._v(" "),v("p",[v("strong",[_._v("2.捕捉信号")]),_._v("。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。")]),_._v(" "),v("p",[v("strong",[_._v("3.忽略信号")]),_._v("。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 "),v("code",[_._v("SIGKILL")]),_._v(" 和 "),v("code",[_._v("SEGSTOP")]),_._v("，它们用于在任何时候中断或结束某一进程。")]),_._v(" "),v("blockquote",[v("p",[_._v("详情参见《Linux-Unix操作手册第20章》")])]),_._v(" "),v("h3",{attrs:{id:"socket"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[_._v("#")]),_._v(" Socket")]),_._v(" "),v("p",[_._v("Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。")]),_._v(" "),v("p",[_._v("我们来看看创建 socket 的系统调用：")]),_._v(" "),v("div",{staticClass:"language-c line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("socket")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" domain"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" type"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" protocal"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("三个参数分别代表：")]),_._v(" "),v("ul",[v("li",[_._v("domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；")]),_._v(" "),v("li",[_._v("type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；")]),_._v(" "),v("li",[_._v("protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；")])]),_._v(" "),v("p",[_._v("根据创建 socket 类型的不同，通信的方式也就不同：")]),_._v(" "),v("ul",[v("li",[_._v("实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；")]),_._v(" "),v("li",[_._v("实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；")]),_._v(" "),v("li",[_._v("实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；")])]),_._v(" "),v("p",[_._v("socket()在成功时返回一个引用在后续系统调用中会用到的新创建的 socket 的文件描述符。")]),_._v(" "),v("blockquote",[v("p",[_._v("详情参见《Linux-Unix操作手册第56章》")])]),_._v(" "),v("h2",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[_._v("#")]),_._v(" 死锁")]),_._v(" "),v("p",[_._v("死锁只有"),v("strong",[_._v("同时满足")]),_._v("以下四个条件才会发生：")]),_._v(" "),v("ul",[v("li",[_._v("资源非共享条件；")]),_._v(" "),v("li",[_._v("占有且等待条件；")]),_._v(" "),v("li",[_._v("非抢占式条件；")]),_._v(" "),v("li",[_._v("循环等待条件；")])])])}),[],!1,null,null,null);v.default=a.exports}}]);